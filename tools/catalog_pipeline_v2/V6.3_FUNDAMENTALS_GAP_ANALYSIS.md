# NSW v6.3 Catalog Creation Fundamentals - Gap Analysis

**Date:** 2025-12-30  
**Status:** üîç ANALYSIS COMPLETE  
**Purpose:** Compare v6.3 fundamentals with current implementation and identify adoption requirements

---

## Executive Summary

The v6.3 Catalog Creation Fundamentals document provides **critical architectural clarity** that is **partially aligned** with our current implementation but has **significant gaps** in:
1. **Price isolation enforcement** (currently prices are in L2, not isolated to price matrix)
2. **Accessory isolation** (accessories are partially handled but not fully externalized)
3. **Range encoding** (not implemented per v6.3 spec)
4. **Sequence preservation** (not explicitly enforced)
5. **L1/L2 boundary clarity** (some ambiguity remains)

**Recommendation:** **ADOPT with modifications** - The fundamentals are sound and will prevent future drift, but require implementation changes.

---

## 1. Core Entity Definitions Comparison

### 1.1 L2 ‚Äî Product Identity

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **MUST contain:** OEM base ref, Product type, Frame/poles, Series | ‚úÖ **ALIGNED** - `build_nsw_l2_products()` extracts these | ‚úÖ PASS |
| **MUST NOT contain:** Voltage, Duty, Current range, KA, Price | ‚ö†Ô∏è **PARTIAL** - L2 doesn't have voltage/duty, but **prices are in L2** | ‚ùå **GAP** |
| **Stability across price updates** | ‚úÖ **ALIGNED** - L2 is stable | ‚úÖ PASS |

**Gap Details:**
- **Current:** Prices are stored in `sku_prices` table (L2 level) per `NSW_DATA_DICTIONARY_v1.0.md`
- **v6.3:** Prices MUST be ONLY in `NSW_PRICE_MATRIX`
- **Impact:** HIGH - This is a fundamental architectural difference

### 1.2 L1 ‚Äî Engineering Configuration

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **MAY contain:** Duty, Voltage, Current, kW/HP, Contacts, Notes | ‚úÖ **ALIGNED** - `build_nsw_l1_config_lines()` includes these | ‚úÖ PASS |
| **MUST NOT contain:** Price, Accessories | ‚úÖ **ALIGNED** - L1 has no price, accessories are separate | ‚úÖ PASS |
| **BASE lines only** | ‚úÖ **ALIGNED** - L1 creates BASE lines | ‚úÖ PASS |

**Status:** ‚úÖ **FULLY ALIGNED**

### 1.3 Variants ‚Äî Selection Dimensions

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Never create new L2** | ‚úÖ **ALIGNED** - Variants are separate | ‚úÖ PASS |
| **May create multiple L1 rows** | ‚úÖ **ALIGNED** - Duty √ó Voltage expansion in L1 | ‚úÖ PASS |
| **Defined in NSW_VARIANT_MASTER** | ‚úÖ **ALIGNED** - `build_nsw_variant_master()` creates this | ‚úÖ PASS |

**Status:** ‚úÖ **FULLY ALIGNED**

### 1.4 Accessories ‚Äî Optional Add-Ons

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Modeled outside L1** | ‚ö†Ô∏è **PARTIAL** - Accessories are in separate sheets but also create FEATURE L1 lines | ‚ö†Ô∏è **GAP** |
| **Use compatibility mapping** | ‚ùå **NOT IMPLEMENTED** - No `NSW_ACCESSORY_COMPATIBILITY` sheet | ‚ùå **GAP** |
| **Use variant system if voltage-dependent** | ‚ùå **NOT IMPLEMENTED** | ‚ùå **GAP** |
| **Priced independently** | ‚ö†Ô∏è **PARTIAL** - Accessories have prices but not in price matrix | ‚ö†Ô∏è **GAP** |
| **MUST NOT multiply across duty/voltage/range/KA** | ‚úÖ **ALIGNED** - Accessories don't multiply | ‚úÖ PASS |
| **MUST NOT appear as BASE L1 rows** | ‚úÖ **ALIGNED** - Accessories are FEATURE lines | ‚úÖ PASS |

**Gap Details:**
- **Current:** Accessories create FEATURE L1 lines (`create_l1_feature_lines_for_accessories()`)
- **v6.3:** Accessories should be handled via `NSW_ACCESSORY_MASTER`, `NSW_ACCESSORY_COMPATIBILITY`, `NSW_PRODUCT_VARIANTS`, `NSW_PRICE_MATRIX`
- **Impact:** MEDIUM - Current approach works but doesn't match v6.3 architecture

---

## 2. Pricing Rules Comparison

### 2.1 Price Isolation Rule

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Prices ONLY in NSW_PRICE_MATRIX** | ‚ùå **NOT ALIGNED** - Prices are in `sku_prices` table (L2 level) | ‚ùå **CRITICAL GAP** |
| **MUST NOT exist in L2, L1, Variant master, Accessory master** | ‚ö†Ô∏è **PARTIAL** - Prices not in L1/variants, but in L2 | ‚ö†Ô∏è **GAP** |

**Gap Details:**
- **Current Architecture:** `sku_prices` table stores prices at L2 SKU level (per `NSW_DATA_DICTIONARY_v1.0.md:280-308`)
- **v6.3 Architecture:** Prices should be ONLY in `NSW_PRICE_MATRIX` Excel sheet
- **Impact:** **CRITICAL** - This is a fundamental architectural difference

**Current Code:**
```python
# tools/catalog_pipeline_v2/scripts/build_nsw_workbook_from_canonical.py:234
def build_nsw_price_matrix(coil_prices, nsw_l2, canonical_rows, wef_date, pricelist_ref, series_bucket='LC1E'):
    """Build NSW_PRICE_MATRIX from coil prices."""
    # Creates price matrix correctly, but backend also has sku_prices table
```

**Required Change:**
- Backend must use `NSW_PRICE_MATRIX` as source of truth
- `sku_prices` table should be deprecated or used only for historical tracking

### 2.2 Price Resolution Order

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **1. Resolve L2 product** | ‚úÖ **ALIGNED** | ‚úÖ PASS |
| **2. Resolve selected variant** | ‚úÖ **ALIGNED** | ‚úÖ PASS |
| **3. Lookup price in NSW_PRICE_MATRIX** | ‚ö†Ô∏è **PARTIAL** - Price matrix exists but backend uses `sku_prices` | ‚ö†Ô∏è **GAP** |

---

## 3. Range Handling Comparison

### 3.1 Range Representation

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Range modeled in L1 only** | ‚úÖ **ALIGNED** - Ranges would be in L1 | ‚úÖ PASS |
| **Encoding: duty_class = <RANGE_TYPE>** | ‚ùå **NOT IMPLEMENTED** - No range encoding logic | ‚ùå **GAP** |
| **duty_current_A = minimum** | ‚ùå **NOT IMPLEMENTED** | ‚ùå **GAP** |
| **catalog_ac1_A = maximum** | ‚ùå **NOT IMPLEMENTED** | ‚ùå **GAP** |

**Gap Details:**
- **Current:** No range handling for values like "25/30 A"
- **v6.3:** Requires specific encoding in L1 using `TOR_RANGE`, `KA_RANGE` duty classes
- **Impact:** MEDIUM - Needed for LRE (thermal overload relay) and other range-based products

**Example from v6.3:**
```
Catalog: "25/30 A"
v6.3 Encoding:
- duty_class = "TOR_RANGE"
- duty_current_A = 25 (minimum)
- catalog_ac1_A = 30 (maximum)
```

---

## 4. Sequence & Ordering Rules Comparison

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Preserve catalog table order** | ‚ö†Ô∏è **NOT EXPLICITLY ENFORCED** - Order may be lost during processing | ‚ö†Ô∏è **GAP** |
| **Order = table first, then row order** | ‚ùå **NOT IMPLEMENTED** - No explicit ordering logic | ‚ùå **GAP** |
| **Never reorder alphabetically or by code** | ‚ö†Ô∏è **PARTIAL** - No explicit reordering, but no guarantee of preservation | ‚ö†Ô∏è **GAP** |

**Gap Details:**
- **Current:** DataFrames may lose original order during processing
- **v6.3:** Requires explicit sequence preservation
- **Impact:** LOW-MEDIUM - Important for visual validation by engineers

**Required Change:**
- Add `sequence_number` or `catalog_order` column to preserve original order
- Ensure all DataFrame operations preserve order (use `.reset_index(drop=False)` where needed)

---

## 5. No SKU Explosion Rule Comparison

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Voltage/duty/range/KA must NOT create new L2 rows** | ‚úÖ **ALIGNED** - L2 is unique per base ref | ‚úÖ PASS |
| **Combinatorial expansion only at L1 and Price matrix** | ‚úÖ **ALIGNED** - Expansion happens in L1 (duty √ó voltage) | ‚úÖ PASS |

**Status:** ‚úÖ **FULLY ALIGNED**

---

## 6. Accessory Isolation Rule Comparison

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Never part of L1 engineering logic** | ‚ö†Ô∏è **PARTIAL** - Accessories create FEATURE L1 lines | ‚ö†Ô∏è **GAP** |
| **Handled via NSW_ACCESSORY_MASTER** | ‚ùå **NOT IMPLEMENTED** - No separate accessory master sheet | ‚ùå **GAP** |
| **Handled via NSW_ACCESSORY_COMPATIBILITY** | ‚ùå **NOT IMPLEMENTED** | ‚ùå **GAP** |
| **Selection via Accessory Picker, not L1** | ‚ö†Ô∏è **PARTIAL** - Accessories are FEATURE lines (L1) | ‚ö†Ô∏è **GAP** |

**Gap Details:**
- **Current:** Accessories create FEATURE L1 lines (`create_l1_feature_lines_for_accessories()`)
- **v6.3:** Accessories should be completely external to L1, selected via Accessory Picker UI
- **Impact:** MEDIUM - Requires UI changes and architectural refactoring

**Current Code:**
```python
# tools/catalog_pipeline_v2/scripts/derive_l1_from_l2.py:298
def create_l1_feature_lines_for_accessories(l2_sku_master, base_l1_lines):
    """Create L1 FEATURE lines for accessories (SC_L4)."""
    # Creates FEATURE L1 lines - this conflicts with v6.3
```

---

## 7. Series-Specific Behavior Comparison

### 7.1 LC1E ‚Äî Power Contactors

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **L1 dimensions: Duty (AC1/AC3) √ó Voltage** | ‚úÖ **ALIGNED** - `build_nsw_l1_config_lines()` does this | ‚úÖ PASS |
| **No range variants** | ‚úÖ **ALIGNED** - LC1E has no ranges | ‚úÖ PASS |
| **Accessories external** | ‚ö†Ô∏è **PARTIAL** - Accessories are separate but also in L1 | ‚ö†Ô∏è **GAP** |

**Status:** ‚úÖ **MOSTLY ALIGNED** (accessory handling needs refinement)

---

## 8. NSW UI Behavior Comparison

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Engineer workflow: Select L2 ‚Üí Configure L1 ‚Üí Add Accessories** | ‚ùì **UNKNOWN** - UI implementation not reviewed | ‚ùì **UNKNOWN** |
| **Engineer never sees accessories in L1** | ‚ö†Ô∏è **CONFLICT** - Current implementation has accessories as FEATURE L1 lines | ‚ö†Ô∏è **GAP** |

**Impact:** MEDIUM - Requires UI/UX changes if adopting v6.3

---

## 9. Summary of Gaps

### Critical Gaps (Must Fix for v6.3 Adoption)

1. **Price Isolation** ‚ùå
   - **Current:** Prices in `sku_prices` table (L2 level)
   - **Required:** Prices ONLY in `NSW_PRICE_MATRIX`
   - **Impact:** Backend architecture change required

2. **Accessory Isolation** ‚ö†Ô∏è
   - **Current:** Accessories create FEATURE L1 lines
   - **Required:** Accessories external, handled via `NSW_ACCESSORY_MASTER` + compatibility mapping
   - **Impact:** Requires new sheets and UI changes

### Medium Gaps (Should Fix)

3. **Range Encoding** ‚ùå
   - **Current:** No range handling
   - **Required:** `TOR_RANGE`, `KA_RANGE` encoding in L1
   - **Impact:** Needed for LRE and other range-based products

4. **Sequence Preservation** ‚ö†Ô∏è
   - **Current:** Order may be lost
   - **Required:** Explicit catalog order preservation
   - **Impact:** Important for visual validation

### Low Gaps (Nice to Have)

5. **Accessory Compatibility Mapping** ‚ùå
   - **Current:** Not implemented
   - **Required:** `NSW_ACCESSORY_COMPATIBILITY` sheet
   - **Impact:** Better accessory selection UX

---

## 10. Documents That Would Be Affected

### Backend/Database Documents
- `docs/PHASE_5/03_DATA_DICTIONARY/NSW_DATA_DICTIONARY_v1.0.md` - Price storage model
- `docs/PHASE_5/04_SCHEMA_CANON/NSW_SCHEMA_CANON_v1.0.md` - Schema definitions
- Backend code that queries `sku_prices` table

### Pipeline Scripts
- `tools/catalog_pipeline_v2/scripts/build_nsw_workbook_from_canonical.py` - Price matrix building
- `tools/catalog_pipeline_v2/scripts/derive_l1_from_l2.py` - Accessory FEATURE line creation
- `tools/catalog_pipeline_v2/scripts/build_l2_from_canonical.py` - L2 price history building

### Design Documents
- `NSW Fundamental Alignment Plan/01_FUNDAMENTALS/MASTER_FUNDAMENTALS_v2.0.md` - May need updates
- `docs/PHASE_5/00_GOVERNANCE/Knowledge_Base/SCHNEIDER_CATALOG_INTERPRETATION_RULES_v1.2.md` - Accessory rules

### UI/UX Documents
- Any UI design docs for accessory selection
- Engineer workflow documentation

---

## 11. Advantages of Adopting v6.3

### ‚úÖ Advantages

1. **Clear Architectural Boundaries**
   - Eliminates ambiguity about where prices belong
   - Clear separation of concerns (L2 = identity, L1 = engineering, Price = commercial)

2. **Price Update Efficiency**
   - Single source of truth (`NSW_PRICE_MATRIX`) makes price updates trivial
   - No need to update L2 rows when prices change

3. **Accessory Handling Clarity**
   - External accessories prevent L1 explosion
   - Compatibility mapping enables better UX

4. **Range Encoding Standardization**
   - Consistent approach for range-based products (LRE, etc.)
   - Engineering-friendly encoding

5. **Sequence Preservation**
   - Enables visual validation against OEM catalogs
   - Better debugging and QA

6. **Prevents Future Drift**
   - Locked rules prevent accidental violations
   - Clear governance model

### ‚ö†Ô∏è Disadvantages / Challenges

1. **Backend Migration Required**
   - Must migrate from `sku_prices` table to `NSW_PRICE_MATRIX` as source of truth
   - Existing code that queries `sku_prices` needs updates

2. **Accessory Architecture Change**
   - Current FEATURE L1 lines approach works but doesn't match v6.3
   - Requires new sheets (`NSW_ACCESSORY_MASTER`, `NSW_ACCESSORY_COMPATIBILITY`)
   - UI changes needed for Accessory Picker

3. **Range Encoding Implementation**
   - New logic needed for range parsing and encoding
   - Series-specific implementation (LRE, etc.)

4. **Sequence Preservation Overhead**
   - Need to track and preserve order throughout pipeline
   - Additional columns/fields required

5. **Breaking Changes**
   - May break existing integrations that expect prices in `sku_prices`
   - Requires careful migration plan

---

## 12. Recommendation

### ‚úÖ **ADOPT v6.3 Fundamentals with Phased Implementation**

**Phase 1: Critical Alignment (Immediate)**
1. ‚úÖ Document v6.3 fundamentals as reference
2. ‚ö†Ô∏è Plan backend migration from `sku_prices` to `NSW_PRICE_MATRIX` as source of truth
3. ‚úÖ Ensure new pipeline outputs match v6.3 structure

**Phase 2: Accessory Refactoring (Short-term)**
1. Create `NSW_ACCESSORY_MASTER` sheet
2. Create `NSW_ACCESSORY_COMPATIBILITY` sheet
3. Refactor accessory handling to be external to L1
4. Update UI for Accessory Picker

**Phase 3: Range Encoding (Medium-term)**
1. Implement range parsing logic
2. Add `TOR_RANGE`, `KA_RANGE` encoding
3. Test with LRE series

**Phase 4: Sequence Preservation (Ongoing)**
1. Add sequence tracking to canonical extraction
2. Preserve order through all transformations
3. Add validation checks

### Why Adopt?

1. **Prevents Drift:** Locked rules prevent future architectural violations
2. **Clear Boundaries:** Eliminates ambiguity about data placement
3. **Price Efficiency:** Single source of truth for prices
4. **Better UX:** External accessories enable better selection experience
5. **Standardization:** Consistent approach across all series

### Migration Strategy

1. **Dual Support Period:** Support both `sku_prices` (legacy) and `NSW_PRICE_MATRIX` (new)
2. **Gradual Migration:** Migrate series by series
3. **Validation:** Ensure parity between old and new approaches
4. **Deprecation:** Phase out `sku_prices` after full migration

---

## 13. Action Items

### Immediate (This Week)
- [ ] Review and approve v6.3 fundamentals document
- [ ] Create migration plan for price isolation
- [ ] Document current vs. v6.3 differences

### Short-term (This Month)
- [ ] Implement `NSW_ACCESSORY_MASTER` sheet generation
- [ ] Implement `NSW_ACCESSORY_COMPATIBILITY` sheet generation
- [ ] Refactor accessory handling to be external

### Medium-term (Next Quarter)
- [ ] Implement range encoding for LRE
- [ ] Add sequence preservation to pipeline
- [ ] Migrate backend from `sku_prices` to `NSW_PRICE_MATRIX`

---

## 14. Additional Points from Updated v6.3 Document

### 14.1 File Handling and Automation Inputs (Section 10)

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Multiple files allowed** - Can provide multiple v6.3 format files | ‚úÖ **ALIGNED** - Pipeline can process multiple files | ‚úÖ PASS |
| **Must respect locked schema, sequence, column rules** | ‚ö†Ô∏è **PARTIAL** - Schema respected, sequence not guaranteed | ‚ö†Ô∏è **GAP** |
| **Output/merge must respect catalog sequence** | ‚ùå **NOT ENFORCED** - No explicit sequence preservation | ‚ùå **GAP** |

**Required Change:**
- Add sequence tracking when merging multiple files
- Ensure output preserves catalog table order

### 14.2 Status and Usage (Section 11)

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Single source of truth for catalog conversion** | ‚ö†Ô∏è **PARTIAL** - Multiple docs exist, need consolidation | ‚ö†Ô∏è **GAP** |
| **Reference in all Page-level/series-level rulebooks** | ‚ùå **NOT IMPLEMENTED** - No explicit references | ‚ùå **GAP** |
| **QC checklists must reference this doc** | ‚ùå **NOT IMPLEMENTED** | ‚ùå **GAP** |

**Required Change:**
- Add references to v6.3 fundamentals in all series rulebooks
- Update QC checklists to reference v6.3 rules

### 14.3 Next Steps After v6.3 (Section 12)

| v6.3 Requirement | Current Implementation | Gap Status |
|------------------|----------------------|------------|
| **Keep as root record for new series** | ‚ö†Ô∏è **PARTIAL** - Need to establish as root | ‚ö†Ô∏è **GAP** |
| **Reference in Page-level rulebooks** | ‚ùå **NOT IMPLEMENTED** | ‚ùå **GAP** |
| **Apply sequence/range rules first for new pages** | ‚ùå **NOT IMPLEMENTED** - No explicit workflow | ‚ùå **GAP** |
| **Version control for rule changes** | ‚ö†Ô∏è **PARTIAL** - Need explicit versioning | ‚ö†Ô∏è **GAP** |

---

## 15. Specific Code Changes Required

### 15.1 Price Isolation - Backend Changes

**File:** `docs/PHASE_5/03_DATA_DICTIONARY/NSW_DATA_DICTIONARY_v1.0.md`

**Current:**
```markdown
#### L2 Price (SKU Price)
**Entity:** `sku_prices` (also referenced as `l2_prices`)
**Purpose:** Price history for L2 SKUs (append-only)
```

**Required Change:**
```markdown
#### L2 Price (DEPRECATED - Use NSW_PRICE_MATRIX)
**Entity:** `sku_prices` (DEPRECATED - kept for historical tracking only)
**Purpose:** Historical price records (read-only, no new inserts)
**NEW SOURCE OF TRUTH:** `NSW_PRICE_MATRIX` Excel sheet
**Migration:** All new prices must be imported from NSW_PRICE_MATRIX
```

**File:** `docs/PHASE_5/04_SCHEMA_CANON/NSW_SCHEMA_CANON_v1.0.md`

**Required Change:**
- Add `NSW_PRICE_MATRIX` as primary price source
- Mark `sku_prices` table as deprecated
- Add migration notes

### 15.2 Price Isolation - Pipeline Script Changes

**File:** `tools/catalog_pipeline_v2/scripts/build_nsw_workbook_from_canonical.py`

**Current Code (Line 234-360):**
```python
def build_nsw_price_matrix(coil_prices, nsw_l2, canonical_rows, wef_date, pricelist_ref, series_bucket='LC1E'):
    """Build NSW_PRICE_MATRIX from coil prices."""
    # Creates price matrix correctly
```

**Required Change:**
```python
def build_nsw_price_matrix(coil_prices, nsw_l2, canonical_rows, wef_date, pricelist_ref, series_bucket='LC1E'):
    """
    Build NSW_PRICE_MATRIX from coil prices.
    
    v6.3 RULE: Prices MUST exist ONLY in NSW_PRICE_MATRIX.
    This is the SINGLE SOURCE OF TRUTH for all pricing.
    Do NOT write prices to L2 or L1 structures.
    
    Price matrix: l2_product_code √ó variant_code ‚Üí price
    """
    # Existing implementation is correct - add documentation
```

**File:** `tools/catalog_pipeline_v2/scripts/build_l2_from_canonical.py`

**Current Code (Line 511-558):**
```python
def build_l2_price_history(expanded_df, pricelist_ref, effective_from, currency, region, source_file_name):
    """Build L2 price history from expanded canonical data."""
    # Creates sku_prices table entries
```

**Required Change:**
```python
def build_l2_price_history(expanded_df, pricelist_ref, effective_from, currency, region, source_file_name):
    """
    Build L2 price history from expanded canonical data.
    
    ‚ö†Ô∏è DEPRECATED: This function creates sku_prices table entries.
    v6.3 RULE: Prices should be in NSW_PRICE_MATRIX only.
    
    This function is kept for:
    1. Historical data migration
    2. Backward compatibility during transition period
    
    TODO: Remove after full migration to NSW_PRICE_MATRIX
    """
    # Add deprecation warning
    import warnings
    warnings.warn(
        "build_l2_price_history is deprecated. Use NSW_PRICE_MATRIX as source of truth per v6.3 fundamentals.",
        DeprecationWarning,
        stacklevel=2
    )
    # Existing implementation...
```

### 15.3 Accessory Isolation - Script Changes

**File:** `tools/catalog_pipeline_v2/scripts/derive_l1_from_l2.py`

**Current Code (Line 298-579):**
```python
def create_l1_feature_lines_for_accessories(l2_sku_master, base_l1_lines):
    """Create L1 FEATURE lines for accessories (SC_L4)."""
    # Creates FEATURE L1 lines - CONFLICTS WITH v6.3
```

**Required Change:**
```python
def create_l1_feature_lines_for_accessories(l2_sku_master, base_l1_lines):
    """
    Create L1 FEATURE lines for accessories (SC_L4).
    
    ‚ö†Ô∏è DEPRECATED PER v6.3: Accessories should NOT be in L1.
    v6.3 RULE: Accessories must be external via:
    - NSW_ACCESSORY_MASTER
    - NSW_ACCESSORY_COMPATIBILITY
    - NSW_PRODUCT_VARIANTS
    - NSW_PRICE_MATRIX
    
    This function is kept for:
    1. Backward compatibility during transition
    2. Legacy system support
    
    TODO: Replace with build_nsw_accessory_master() and build_nsw_accessory_compatibility()
    """
    import warnings
    warnings.warn(
        "create_l1_feature_lines_for_accessories is deprecated per v6.3. "
        "Use NSW_ACCESSORY_MASTER and compatibility mapping instead.",
        DeprecationWarning,
        stacklevel=2
    )
    # Existing implementation...
```

**New File Required:** `tools/catalog_pipeline_v2/scripts/build_nsw_accessory_master.py`

```python
def build_nsw_accessory_master(accessory_skus, series_bucket):
    """
    Build NSW_ACCESSORY_MASTER from accessory SKUs.
    
    v6.3 RULE: Accessories are modeled outside L1.
    This sheet contains all accessory definitions.
    """
    # Implementation needed
    pass

def build_nsw_accessory_compatibility(accessory_skus, nsw_l2, series_bucket):
    """
    Build NSW_ACCESSORY_COMPATIBILITY mapping.
    
    v6.3 RULE: Accessories use compatibility mapping.
    Maps which accessories are compatible with which L2 products.
    """
    # Implementation needed
    pass
```

**File:** `tools/catalog_pipeline_v2/scripts/build_nsw_workbook_from_canonical.py`

**Required Change:**
```python
# Add new functions after build_nsw_price_matrix()

def build_nsw_accessory_master(accessories, series_bucket):
    """Build NSW_ACCESSORY_MASTER per v6.3 fundamentals."""
    # New implementation

def build_nsw_accessory_compatibility(accessories, nsw_l2, series_bucket):
    """Build NSW_ACCESSORY_COMPATIBILITY per v6.3 fundamentals."""
    # New implementation

# Update build_nsw_workbook() to include new sheets:
def build_nsw_workbook(...):
    # ... existing code ...
    
    # v6.3: Add accessory sheets (if accessories exist)
    if accessories is not None and len(accessories) > 0:
        nsw_accessory_master = build_nsw_accessory_master(accessories, series_bucket)
        nsw_accessory_compatibility = build_nsw_accessory_compatibility(accessories, nsw_l2, series_bucket)
        
        nsw_accessory_master.to_excel(writer, sheet_name='NSW_ACCESSORY_MASTER', index=False)
        nsw_accessory_compatibility.to_excel(writer, sheet_name='NSW_ACCESSORY_COMPATIBILITY', index=False)
```

### 15.4 Range Encoding - New Implementation

**New File Required:** `tools/catalog_pipeline_v2/scripts/encode_ranges.py`

```python
def encode_range_in_l1(range_text, range_type='TOR_RANGE'):
    """
    Encode catalog range values per v6.3 fundamentals.
    
    v6.3 RULE:
    - duty_class = range type (e.g., TOR_RANGE, KA_RANGE)
    - duty_current_A = minimum value
    - catalog_ac1_A = maximum value
    
    Example: "25/30 A" -> duty_class="TOR_RANGE", duty_current_A=25, catalog_ac1_A=30
    """
    import re
    
    # Parse range pattern (e.g., "25/30", "25-30", "25 to 30")
    range_match = re.search(r'(\d+(?:\.\d+)?)\s*[/-]\s*(\d+(?:\.\d+)?)', str(range_text))
    if range_match:
        min_val = float(range_match.group(1))
        max_val = float(range_match.group(2))
        return {
            'duty_class': range_type,
            'duty_current_A': min_val,
            'catalog_ac1_A': max_val,
            'notes_raw': f"Range: {range_text}"  # Preserve original for traceability
        }
    return None
```

**File:** `tools/catalog_pipeline_v2/scripts/build_nsw_l1_config_lines()` 

**Required Change:**
```python
# Add range encoding logic
from .encode_ranges import encode_range_in_l1

# In build_nsw_l1_config_lines():
# Check for range values in current/KA fields
if 'current_range' in base_canonical or 'ka_range' in base_canonical:
    range_text = base_canonical.get('current_range') or base_canonical.get('ka_range')
    range_type = 'TOR_RANGE' if 'current_range' in base_canonical else 'KA_RANGE'
    range_encoding = encode_range_in_l1(range_text, range_type)
    if range_encoding:
        duty_class = range_encoding['duty_class']
        duty_current_A = range_encoding['duty_current_A']
        catalog_ac1_A = range_encoding['catalog_ac1_A']
```

### 15.5 Sequence Preservation - Implementation

**File:** `tools/catalog_pipeline_v2/scripts/build_nsw_workbook_from_canonical.py`

**Required Change:**
```python
def build_nsw_l2_products(canonical_rows, series_name, series_bucket):
    """
    Build NSW_L2_PRODUCTS from canonical rows.
    
    v6.3 RULE: Must preserve catalog table sequence.
    """
    # Add sequence tracking
    canonical_rows = canonical_rows.copy()
    
    # Add sequence column if not present
    if 'catalog_sequence' not in canonical_rows.columns:
        # Preserve original index as sequence
        canonical_rows['catalog_sequence'] = canonical_rows.index
    
    # Sort by sequence before processing
    canonical_rows = canonical_rows.sort_values('catalog_sequence')
    
    # ... existing code ...
    
    # Include sequence in output
    l2_list.append({
        # ... existing fields ...
        'catalog_sequence': base_row.get('catalog_sequence', idx),  # Preserve sequence
    })
    
    # Sort final output by sequence
    nsw_l2 = pd.DataFrame(l2_list)
    nsw_l2 = nsw_l2.sort_values('catalog_sequence')
    
    return nsw_l2
```

**File:** All extraction scripts

**Required Change:**
```python
# In canonical extraction scripts (e.g., lc1e_extract_page8_v6.py):
# Add sequence tracking during extraction

def extract_p8_t1(...):
    # ... existing code ...
    
    # Track sequence: table_id + row position
    table_sequence = 1  # P8_T1 is first table
    row_sequence = 0
    
    for data_idx in range(header_row + 1, ...):
        row_sequence += 1
        
        canonical_rows.append({
            # ... existing fields ...
            'catalog_sequence': f"{table_sequence:02d}_{row_sequence:04d}",  # e.g., "01_0001"
            'table_id': table_config['table_id'],
            'source_row_id': str(data_idx + 1),
        })
```

---

## 16. Execution Checklist (Before Implementation)

### Phase 1: Documentation Updates (Week 1)

- [ ] **Update NSW_DATA_DICTIONARY_v1.0.md**
  - [ ] Mark `sku_prices` as deprecated
  - [ ] Add `NSW_PRICE_MATRIX` as primary source
  - [ ] Add migration notes

- [ ] **Update NSW_SCHEMA_CANON_v1.0.md**
  - [ ] Document `NSW_PRICE_MATRIX` schema
  - [ ] Add `NSW_ACCESSORY_MASTER` schema
  - [ ] Add `NSW_ACCESSORY_COMPATIBILITY` schema
  - [ ] Add sequence preservation requirements

- [ ] **Create/Update Series Rulebooks**
  - [ ] Add reference to v6.3 fundamentals in all series rulebooks
  - [ ] Update LC1E rulebook with v6.3 references
  - [ ] Create template for new series rulebooks

- [ ] **Update QC Checklists**
  - [ ] Add v6.3 compliance checks
  - [ ] Add sequence preservation validation
  - [ ] Add price isolation validation
  - [ ] Add accessory isolation validation

### Phase 2: Code Changes - Price Isolation (Week 2-3)

- [ ] **Add Deprecation Warnings**
  - [ ] Update `build_l2_price_history()` with deprecation warning
  - [ ] Add comments in all price-related functions
  - [ ] Document migration path

- [ ] **Verify NSW_PRICE_MATRIX Generation**
  - [ ] Review `build_nsw_price_matrix()` implementation
  - [ ] Ensure all prices go to price matrix
  - [ ] Add validation that no prices leak to L2/L1

- [ ] **Backend Migration Planning**
  - [ ] Create migration script: `sku_prices` ‚Üí `NSW_PRICE_MATRIX`
  - [ ] Plan dual-support period
  - [ ] Document rollback procedure

### Phase 3: Code Changes - Accessory Isolation (Week 4-5)

- [ ] **Create New Accessory Functions**
  - [ ] Implement `build_nsw_accessory_master()`
  - [ ] Implement `build_nsw_accessory_compatibility()`
  - [ ] Add unit tests

- [ ] **Update Workbook Builder**
  - [ ] Add `NSW_ACCESSORY_MASTER` sheet generation
  - [ ] Add `NSW_ACCESSORY_COMPATIBILITY` sheet generation
  - [ ] Update `build_nsw_workbook()` function

- [ ] **Deprecate Old Accessory Logic**
  - [ ] Add deprecation warning to `create_l1_feature_lines_for_accessories()`
  - [ ] Keep for backward compatibility
  - [ ] Document migration path

### Phase 4: Code Changes - Range Encoding (Week 6)

- [ ] **Create Range Encoding Module**
  - [ ] Implement `encode_ranges.py`
  - [ ] Add `encode_range_in_l1()` function
  - [ ] Support TOR_RANGE, KA_RANGE types
  - [ ] Add unit tests

- [ ] **Integrate Range Encoding**
  - [ ] Update `build_nsw_l1_config_lines()` to use range encoding
  - [ ] Test with LRE series (when available)
  - [ ] Document range encoding examples

### Phase 5: Code Changes - Sequence Preservation (Week 7)

- [ ] **Add Sequence Tracking to Extraction**
  - [ ] Update `lc1e_extract_page8_v6.py` to track sequence
  - [ ] Add `catalog_sequence` column to canonical output
  - [ ] Preserve table order and row order

- [ ] **Preserve Sequence Through Pipeline**
  - [ ] Update `build_nsw_l2_products()` to preserve sequence
  - [ ] Update `build_nsw_l1_config_lines()` to preserve sequence
  - [ ] Ensure no sorting breaks sequence

- [ ] **Add Sequence Validation**
  - [ ] Create validation function to check sequence preservation
  - [ ] Add to QC checklist
  - [ ] Document expected sequence format

### Phase 6: Testing & Validation (Week 8)

- [ ] **End-to-End Testing**
  - [ ] Test LC1E extraction with v6.3 compliance
  - [ ] Verify price isolation (no prices in L2/L1)
  - [ ] Verify accessory isolation (no accessories in L1 BASE)
  - [ ] Verify sequence preservation
  - [ ] Verify range encoding (when applicable)

- [ ] **Backward Compatibility Testing**
  - [ ] Ensure old scripts still work (with deprecation warnings)
  - [ ] Test migration from old format to new format
  - [ ] Verify no data loss during migration

- [ ] **Documentation Review**
  - [ ] Review all updated documentation
  - [ ] Ensure v6.3 references are correct
  - [ ] Update user guides if needed

### Phase 7: Deployment (Week 9)

- [ ] **Deploy Updated Scripts**
  - [ ] Deploy with deprecation warnings (not breaking changes)
  - [ ] Monitor for issues
  - [ ] Collect feedback

- [ ] **Gradual Migration**
  - [ ] Migrate one series at a time
  - [ ] Validate each migration
  - [ ] Document lessons learned

---

## 17. Conclusion

The v6.3 Catalog Creation Fundamentals provide **excellent architectural clarity** and will **prevent future drift**. The fundamentals are **mostly aligned** with our current implementation, with **critical gaps** in:

1. Price isolation (backend architecture)
2. Accessory isolation (requires refactoring)
3. Range encoding (new feature)
4. Sequence preservation (needs enforcement)

**Recommendation:** **ADOPT with phased implementation** to minimize disruption while achieving architectural alignment.

**Execution Priority:**
1. **HIGH:** Documentation updates and deprecation warnings (non-breaking)
2. **HIGH:** Price isolation planning and backend migration plan
3. **MEDIUM:** Accessory isolation refactoring
4. **MEDIUM:** Range encoding implementation
5. **LOW:** Sequence preservation (can be done incrementally)

---

**Status:** ‚úÖ **ANALYSIS COMPLETE + EXECUTION PLAN READY**  
**Next Step:** Review execution checklist with team and begin Phase 1

