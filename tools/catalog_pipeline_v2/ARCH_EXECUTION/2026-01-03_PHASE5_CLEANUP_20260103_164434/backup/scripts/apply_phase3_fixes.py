#!/usr/bin/env python3
"""
Phase 3: Update Freeze Documents - Apply fixes to create v1.2 versions

This script:
1. Reads NSW_TERMINOLOGY_AND_LEVELS_FREEZE_v1.md
2. Applies 10 fixes from patch review
3. Creates NSW_TERMINOLOGY_AND_LEVELS_FREEZE_v1.2.md (new file, never overwrites)
4. Reads NSW_SHEET_SET_INDEX_v1.md
5. Applies 5 fixes from patch review
6. Creates NSW_SHEET_SET_INDEX_v1.2.md (new file, never overwrites)

Safety:
- Always creates new files with v1.2 suffix
- Never overwrites original v1 files
- Uses text-based processing (no pandas)
"""

import argparse
import re
from pathlib import Path
from datetime import datetime


def read_file_safe(file_path: Path) -> str:
    with open(file_path, "r", encoding="utf-8") as f:
        return f.read()


def stamp_content(content: str) -> str:
    stamp = (
        f"**Generated By:** scripts/apply_phase3_fixes.py  \n"
        f"**Generated On:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  \n"
        f"**Source:** v1 files (unchanged)  \n\n---\n\n"
    )
    return stamp + content


def write_file_safe(file_path: Path, content: str) -> None:
    file_path.parent.mkdir(parents=True, exist_ok=True)
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"  ✓ Created: {file_path}")


def apply_terminology_fixes(content):
    """Apply 10 fixes to NSW_TERMINOLOGY_AND_LEVELS_FREEZE_v1.md"""
    print("\nApplying fixes to NSW_TERMINOLOGY_AND_LEVELS_FREEZE...")
    
    # Fix A1: Add Engineering Bank Operating Reality Section (Section 0)
    if "## 0) Engineering Bank Operating Reality" not in content:
        # Find the first section (usually "## 1)")
        match = re.search(r'^(##\s+1[\)\.])', content, re.MULTILINE)
        if match:
            operating_reality = """## 0) Engineering Bank Operating Reality

**Purpose:** This section defines the authoritative operating reality for Engineering Bank canonical meanings. It overrides ambiguous interpretations and provides the ground truth for all catalog work.

### 0.1 Structural vs Capability vs Attribute Separation (MANDATORY)

**Three distinct concepts must never be confused:**

1. **Structural Construction Layers (SC_Lx / SCL)**
   - Physical construction elements: Frame, Poles, Actuation, Mounting, Terminals, Zones, Enclosure, Variants
   - Describes "how it's built" not "what it does"
   - SC_Lx MUST NOT be used for options, features, or capabilities
   - Example: `SC_L1 = FRAME-1` (structural), NOT `SC_L1 = AC_COIL` (capability)

2. **Capability**
   - Engineering options/features: inclusion/exclusion flag set (multi-select)
   - Uses `capability_codes` column (primary)
   - Optional `capability_class_1..4` for grouping axes (if needed)
   - Example: `capability_codes = AUX_CONTACT_BLOCK, MECHANICAL_INTERLOCK`

3. **Attributes (ATTR_*)**
   - Additional specification parameters
   - Populated only if explicitly defined in OEM catalog
   - Example: `ATTR_VOLTAGE = 230V`, `ATTR_CURRENT = 16A`

**Hard Rule:** SC_Lx and capability are separate concepts. Never auto-map SC_Lx to capability_class_x.

### 0.1B Two-Worlds Warning (Mandatory)

Business classification and Engineering selection are different axes:
- Business Category/Segment = classification only (navigation/reporting)
- SCL/Capability/Attributes = engineering selection/spec

Forbidden:
- Inferring capability from business classification
- Using business terms as engineering terms

### 0.2 Generic Naming Neutrality Rule

**MANDATORY:** Generic names and descriptions must be vendor- and series-neutral.

- Do NOT include: OEM name (Schneider, ABB, Siemens, etc.)
- Do NOT include: Series (LC1E, GZ1E, NSX, NW, etc.)
- Do NOT include: Family names
- Make/Series are allowed ONLY at L2 (SKU level)

**Examples:**
- ✅ Correct: "Contactor, 3-Pole, AC Coil"
- ❌ Wrong: "Schneider LC1E Contactor"
- ❌ Wrong: "LC1E 3-Pole Contactor"

### 0.3 Layer Discipline (Hard Boundary)

- Layer-1 (Catalog → Item Master): record facts only; no inference/validation/dependency logic.
- Layer-2 (Engineering/BOM): apply rules, capability logic, dependencies, QC.

Reminder:
- L0/L1/L2 are engineering levels (intent/spec/SKU).
- Make/Series/Price are L2-only.

### 0.4 Sheet Semantics

Engineering Bank sheets have canonical meanings:
- `SC_DEFINITION` defines what SC_Lx represents (structural only)
- `TERMINOLOGY_ALIASES` maps terms (SC_Lx → SCL, not capability)
- `DECISION_REGISTER` records locked decisions

### 0.5 AI Safety Boundary (Mandatory)

Excel protection applies only inside Excel.
AI tools ignore hidden/locked sheets.

- Never upload MASTER files to AI tools.
- Only upload AI-SAFE WORK files containing DATA_* sheets.

---

"""
            content = content[:match.start()] + operating_reality + content[match.start():]
            print("  ✓ Fix A1: Added Engineering Bank Operating Reality section")
    
    # Fix A2: Fix SC_Lx Definition (replace incorrect mapping - robust with fallback)
    old_sc_def = r'SC_L1.*capability_class'
    if re.search(old_sc_def, content, re.IGNORECASE):
        # Replace any single-line statement that directly maps SC_Lx to capability_class
        content = re.sub(
            r".*SC_L1.*capability_class.*\n",
            "SC_L1..SC_L8 | SCL (Structural Construction Layers) | Physical construction elements (Frame, Poles, Actuation, Mounting, Terminals, Zones, Enclosure, Variants)\n",
            content,
            flags=re.IGNORECASE,
        )
        print("  ✓ Fix A2: Removed SC_Lx → capability_class line mapping (if present)")

    # Fallback authoritative statement to guarantee correctness
    if "SC_Lx Final Statement (Authoritative)" not in content:
        # Only insert if any legacy hint exists (avoid adding noise)
        if re.search(r"SC_L1", content, re.IGNORECASE):
            sc_override = """
### SC_Lx Final Statement (Authoritative)

- SC_L1..SC_L8 represent **SCL (Structural Construction Layers)** only.
- SC_Lx describes physical construction (frame, poles, actuation, mounting, terminals, zones, enclosure, variants).
- SC_Lx MUST NOT be used for capability/options/features.
- Capability is represented separately using `capability_codes` (and optional capability_class_1..4 if needed).
- Never auto-map SC_Lx to capability_class_x.
"""
            insert_pos = content.find("## 1")
            if insert_pos != -1:
                content = content[:insert_pos] + sc_override + "\n\n" + content[insert_pos:]
            else:
                content += "\n\n" + sc_override
            print("  ✓ Fix A2-Fallback: Appended authoritative SC_Lx override")
    
    # Fix A3: Add "Do Not Force Fill" Rule
    if ("Universal Population Rule" not in content) and ("Do Not Force Fill" not in content):
        force_fill_rule = """
### Universal Population Rule (Applies to ALL SC_Lx and ATTR_*)

**MANDATORY:** Populate SC_Lx or ATTR_* fields ONLY if explicitly defined in the OEM catalog.

- Do NOT substitute series, family, or marketing names
- Do NOT guess or infer values
- Leave blank if not explicitly stated in source catalog
- Applies across all product types

Examples:
- ✅ Correct: If catalog says "Frame: FRAME-1", populate `SC_L1 = FRAME-1`
- ❌ Wrong: If catalog doesn't mention frame, do NOT populate `SC_L1` with a series name
"""
        # Try insert after Section 3; else append
        match = re.search(r"(##\s+3[\)\.])", content, re.MULTILINE)
        if match:
            # insert after section 3 header line
            insert_pos = match.end()
            content = content[:insert_pos] + "\n" + force_fill_rule + "\n" + content[insert_pos:]
        else:
            content += "\n\n" + force_fill_rule
        print("  ✓ Fix A3: Added Universal Population / Do Not Force Fill rule")
    
    # Fix A4: Add Generic Naming rule (prevent duplicates)
    if ("Generic Naming Rule" not in content) and ("Generic Naming Neutrality" not in content):
        generic_rule = """
### Generic Naming Rule (MANDATORY)

Generic names and descriptions must be vendor- and series-neutral.

Forbidden in Generic Names:
- OEM names: Schneider, ABB, Siemens, etc.
- Series: LC1E, GZ1E, NSX, NW, etc.
- Family names

Allowed:
- Make/Series are allowed ONLY in identity fields and at L2 (SKU level).
"""
        match = re.search(r"(##\s+4[\)\.])", content, re.MULTILINE)
        if match:
            insert_pos = match.end()
            content = content[:insert_pos] + "\n" + generic_rule + "\n" + content[insert_pos:]
        else:
            content += "\n\n" + generic_rule
        print("  ✓ Fix A4: Added Generic Naming Rule")
    
    # Fix A5: Fix Contactor Example
    old_contactor = r'Capability_Class_2:\s*AC Coil'
    new_contactor = """**Capability Examples:**
- WITH_OLR (Overload Relay)
- AUX_CONTACT_BLOCK
- MECHANICAL_INTERLOCK

**Note:** Coil voltage is L2-only (SKU differentiator), NOT a capability class.
AC1/AC3 are rating contexts (L1 spec / SKU_RATINGS), NOT capability."""
    
    if re.search(old_contactor, content):
        # Find and replace the contactor example section
        content = re.sub(
            r'Capability_Class_2:\s*AC Coil.*?Capability_Class_3:\s*AC1\s*/\s*AC3',
            new_contactor,
            content,
            flags=re.DOTALL
        )
        print("  ✓ Fix A5: Fixed Contactor example")
    
    # Fix A6: Fix business_subcategory Statement
    old_business = r'Current Code Usage:\s*✅\s*business_subcategory already used in codebase \(aligned!\)'
    new_business = """Current Code Usage: ✅ business_subcategory exists in codebase and is treated as legacy alias for business_segment during transition. This prevents future teams from thinking "SubCategory is the right word"."""
    
    if re.search(old_business, content):
        content = re.sub(old_business, new_business, content)
        print("  ✓ Fix A6: Fixed business_subcategory statement")
    
    # Fix A7: Removed - Two-Worlds warning is now in Section 0 (0.1B)
    
    # Fix A8: Capability vs Feature Line separation (ensure present)
    if "Capability vs Feature Line" not in content:
        content += """
### Capability vs Feature Line (Separation)

- Capability = inclusion/exclusion flags (multi-select)
- Feature Line = separate L1 line ONLY when it affects L2 explosion or vendor variability
"""
        print("  ✓ Fix A8: Added Capability vs Feature Line separation (append)")
    
    # Fix A9: Tighten SC_Lx Rename Scope
    old_rename = r'capability_class_1\s*…\s*capability_class_4\s*\(preferred\)'
    new_rename = """capability_class_1 … capability_class_4 (preferred)

**Transitional Note:**
- In transitional phase, data model remains SC_L1–SC_L4 in storage where required
- capability_class_x may be used as UI/documentation alias
- Avoid breaking migrations
- Matches "193 usages" reality and keeps it implementation-safe"""
    
    if re.search(old_rename, content):
        content = re.sub(old_rename, new_rename, content)
        print("  ✓ Fix A9: Tightened SC_Lx rename scope")
    
    # Fix A10: Name collision note (ensure present)
    if "Name Collision" not in content:
        content += """
### Name Collision Note

Business Segment and Item/ProductType may share the same label (e.g., "Contactor").
They are still different concepts. Never infer mapping based on matching names.
"""
        print("  ✓ Fix A10: Added Name Collision note (append)")
    
    # Update version label if present
    content = content.replace("**Status:** FINAL FOR PROJECT USE", "**Status:** FINAL FOR PROJECT USE (v1.2)")
    # Date: only update if exact format exists; otherwise keep original.
    content = re.sub(r"\*\*Date:\*\*\s*\d{4}-\d{2}-\d{2}", f"**Date:** {datetime.now().strftime('%Y-%m-%d')}", content)

    return content


def apply_sheet_index_fixes(content):
    """Apply 5 fixes to NSW_SHEET_SET_INDEX_v1.md"""
    print("\nApplying fixes to NSW_SHEET_SET_INDEX...")
    
    # Fix B1: Mapping table
    if "Engineering Bank Mapping Table" not in content:
        mapping_table = """
### Engineering Bank Mapping Table (Authoritative)

| Cursor/Pipeline Sheet | Engineering Bank Sheet | Notes |
|----------------------|------------------------|-------|
| NSW_SKU_MASTER_CANONICAL | DATA_SKU_PRICE_LIST | L2 SKU identity |
| NSW_ACCESSORY_SKU_MASTER | DATA_ACCESSORY_PRICE_LIST | Accessory SKU list |
| NSW_CATALOG_CHAIN_MASTER | DATA_ITEM_MASTER | Layer-1 minimal intent |
| NSW_PRICE_MATRIX_CANONICAL | PRICE_MATRIX | Commercial layer |

Note: Engineering Bank naming is authoritative for AI-assisted catalog work.
"""
        # Insert near top after Purpose or Section 2; else append
        match = re.search(r"(##\s+3[\)\.])", content, re.MULTILINE)
        if match:
            content = content[:match.start()] + mapping_table + "\n\n" + content[match.start():]
        else:
            content += "\n\n" + mapping_table
        print("  ✓ Fix B1: Added Engineering Bank mapping table")
    
    # Fix B2: Decision closed chain
    if "Decision CLOSED" not in content:
        content += """
### Decision CLOSED (Catalog Chain)

- NSW_CATALOG_CHAIN_MASTER is canonical for continuity.
- NSW_L1_CONFIG_LINES is legacy parse output and becomes archive-ready after chain verification QC.
"""
        print("  ✓ Fix B2: Added Catalog Chain decision CLOSED (append)")
    
    # Fix B3: NSW_L2_PRODUCTS status -> LEGACY
    content = re.sub(r"(NSW_L2_PRODUCTS\s*\|\s*)ACTIVE", r"\1LEGACY", content, flags=re.IGNORECASE)
    
    # Fix B5: Alias support block
    if "Alias Support During Transition" not in content:
        content += """
### Alias Support During Transition

- business_subcategory is a legacy alias for business_segment
- SC_Lx are structural (SCL), not capability_class
"""
        print("  ✓ Fix B5: Added Alias support block (append)")
    
    # Version updates
    content = content.replace("**Status:** FINAL", "**Status:** FINAL (v1.2)")
    content = re.sub(r"\*\*Last Reviewed:\*\*\s*\d{4}-\d{2}-\d{2}", f"**Last Reviewed:** {datetime.now().strftime('%Y-%m-%d')}", content)
    return content


def main():
    parser = argparse.ArgumentParser(
        description='Phase 3: Apply fixes to freeze documents and create v1.2 versions'
    )
    parser.add_argument(
        '--input-dir',
        default='.',
        help='Directory containing v1 freeze documents (default: current directory)'
    )
    parser.add_argument(
        '--output-dir',
        default=None,
        help='Directory for v1.2 output files (default: same as input-dir)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be changed without creating files'
    )
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_dir)
    output_dir = Path(args.output_dir) if args.output_dir else input_dir
    
    print("=" * 80)
    print("Phase 3: Update Freeze Documents")
    print("=" * 80)
    print(f"Input directory: {input_dir}")
    print(f"Output directory: {output_dir}")
    print(f"Mode: {'DRY RUN' if args.dry_run else 'APPLY'}")
    print()
    
    # Process NSW_TERMINOLOGY_AND_LEVELS_FREEZE_v1.md
    terminology_v1 = input_dir / "NSW_TERMINOLOGY_AND_LEVELS_FREEZE_v1.md"
    terminology_v12 = output_dir / "NSW_TERMINOLOGY_AND_LEVELS_FREEZE_v1.2.md"
    
    if terminology_v1.exists():
        print(f"Processing: {terminology_v1.name}")
        content = read_file_safe(terminology_v1)
        updated = apply_terminology_fixes(content)
        updated = stamp_content(updated)

        if args.dry_run:
            print(f"  Would create: {terminology_v12}")
        else:
            if terminology_v12.exists():
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                terminology_v12 = output_dir / f"NSW_TERMINOLOGY_AND_LEVELS_FREEZE_v1.2_{ts}.md"
            write_file_safe(terminology_v12, updated)
    else:
        print(f"⚠️ Missing: {terminology_v1}")
    
    # Process NSW_SHEET_SET_INDEX_v1.md
    sheet_index_v1 = input_dir / "NSW_SHEET_SET_INDEX_v1.md"
    sheet_index_v12 = output_dir / "NSW_SHEET_SET_INDEX_v1.2.md"
    
    if sheet_index_v1.exists():
        print(f"\nProcessing: {sheet_index_v1.name}")
        content = read_file_safe(sheet_index_v1)
        updated = apply_sheet_index_fixes(content)
        updated = stamp_content(updated)

        if args.dry_run:
            print(f"  Would create: {sheet_index_v12}")
        else:
            if sheet_index_v12.exists():
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                sheet_index_v12 = output_dir / f"NSW_SHEET_SET_INDEX_v1.2_{ts}.md"
            write_file_safe(sheet_index_v12, updated)
    else:
        print(f"⚠️ Missing: {sheet_index_v1}")
    
    print("\n" + "=" * 80)
    print("DRY RUN COMPLETE" if args.dry_run else "✅ Phase 3 Complete - v1.2 files created")
    print("=" * 80)
    print("\nNote: Original v1 files were NOT modified.")


if __name__ == "__main__":
    main()

