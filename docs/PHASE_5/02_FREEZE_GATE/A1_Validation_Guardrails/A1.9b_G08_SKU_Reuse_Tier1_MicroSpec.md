# G-08 ‚Äî L1‚ÄìSKU Reuse Is Allowed and Expected (Tier-1 Micro-Spec)

> **‚ö†Ô∏è IMPORTANT: This is an ADDITIVE enhancement to A1.9, not a replacement.**  
> The primary reference remains `A1.9_Guardrail_G08_L1_SKU_Reuse_Is_Allowed_and_Expected.md`.  
> This micro-spec provides governance-grade depth for audit, future-proofing, and developer clarity.  
> Both documents work together: A1.9 for freeze-gate verification, A1.9b for deep implementation guidance.

**Phase:** Phase-5  
**Category:** A ‚Äî Validation Guardrails (Tier-1)  
**Rule ID:** G-08  
**Status:** üîí LOCKED  
**Date:** 2026-01-27  
**Template:** Tier-1 Micro-Spec (CANONICAL)  
**Primary Reference:** A1.9_Guardrail_G08_L1_SKU_Reuse_Is_Allowed_and_Expected.md (Freeze-Gate Verified)

‚∏ª

## 1Ô∏è‚É£ Rule Identifier

- **Rule ID:** G-08
- **Category:** Validation / System Correctness / Data Model Governance
- **Phase Introduced:** Phase-5
- **Risk Class:** üî¥ Tier-1 (System Correctness / Workflow Integrity)

‚∏ª

## 2Ô∏è‚É£ Intent (What This Rule Protects)

**Protection:** G-08 prevents incorrect "uniqueness assumptions" that would break estimation workflows, inflate catalog complexity, and cause unnecessary SKU duplication. It ensures that SKU reuse is treated as first-class, expected behavior, not a data anomaly.

**If Violated:**
- Normal estimation workflows break (same SKU used in multiple contexts)
- Catalog complexity explodes (duplicate SKUs created unnecessarily)
- L1‚ÜíL2 mapping logic fails (many-to-one mapping blocked)
- Totals calculations become incorrect (deduplication errors)
- System incorrectly rejects valid commercial scenarios
- Engineers forced to create duplicate SKUs to work around false uniqueness constraints

**Why Beyond Schema:** Schema can enforce absence of uniqueness constraints, but cannot prevent developers from:
- Adding uniqueness constraints in future migrations
- Implementing validation logic that rejects reuse
- Writing aggregation code that deduplicates by SKU
- Creating UI assumptions that one SKU = one line

‚∏ª

## 3Ô∏è‚É£ Business Rationale (Why This Must Exist)

### System Correctness Risk Prevented
- **Workflow breakage:** Same SKU is often used repeatedly (standard contactors, breakers, relays)
- **Catalog explosion:** Without reuse, system would force duplicate SKUs for same product
- **L1‚ÜíL2 mapping failure:** Many-to-one mapping (multiple L1 lines ‚Üí same SKU) is core requirement

### Financial Risk Prevented
- **Incorrect totals:** Deduplication by SKU causes wrong quotation totals
- **Pricing inconsistency:** Duplicate SKUs lead to price maintenance overhead

### User-Behavior Risk Prevented
- **Engineers creating workarounds:** Forced to create fake SKU variations to satisfy false uniqueness
- **UI confusion:** Systems that assume 1 SKU = 1 line break down when reuse occurs

### Why Common Sense Is Not Enough
- **Uniqueness is a default assumption:** Many developers assume "one quote = one SKU instance"
- **Deduplication seems "clean":** It's tempting to collapse duplicate SKUs for UI simplicity
- **Database normalization bias:** Traditional normalization suggests uniqueness, but commercial reality requires reuse
- **Without explicit rule, future developers will "fix" perceived duplicates**

‚∏ª

## 4Ô∏è‚É£ Canonical Scope (Where It Applies)

| Dimension | Applies | Notes |
|-----------|---------|-------|
| Schema | ‚úÖ | **Primary enforcement** ‚Äî absence of uniqueness constraints |
| Service Layer | ‚úÖ | **Primary enforcement** ‚Äî validation logic must allow reuse |
| Compute / Engine | ‚úÖ | **Primary enforcement** ‚Äî aggregation must NOT deduplicate by SKU |
| API / Validator | ‚úÖ | **Must allow** ‚Äî no validation errors for SKU reuse |
| Audit | ‚úÖ | **Per-line audit** ‚Äî traceability remains line-scoped |
| UI | ‚ö†Ô∏è | UI should NOT assume 1 SKU = 1 line (advisory, not authoritative) |

‚∏ª

## 5Ô∏è‚É£ Schema Behavior (Hard Guarantees)

### Tables & Columns

**Table:** `quote_bom_items`

**Relevant Columns:**
- `product_id` (BIGINT, NULLABLE)
  - **FK to:** `products.id` (ondelete='SET NULL')
  - **Represents:** L2 commercial identity (SKU reference)
  - **Note:** In current schema, L2 commercial identity is represented by `product_id`

- `quotation_id` (BIGINT, NOT NULL)
  - **FK to:** `quotations.id`

### Explicit Absences (Critical ‚Äî Primary Enforcement)

#### Absence 1: No Uniqueness Constraint on `(quotation_id, product_id)`

**Required Absence:**
- **No unique constraint** on `(quotation_id, product_id)` combination
- **Rationale:** Allows same SKU to appear multiple times in same quotation

**Evidence:**
- **Migration:** `20260104_110400_create_schema_canon_v1_0_l1_l2_quo_pricing.py`
- **Verification:** Search for UNIQUE constraints on `quote_bom_items` involving `product_id`
- **Result:** None found (only non-unique indexes)

**Index Presence (Correct):**
- `idx_quote_bom_items_product_id` exists (line 480)
- **Type:** Non-unique index (`unique=False`)
- **Purpose:** Query performance, NOT uniqueness enforcement

#### Absence 2: No Uniqueness Constraint on `(tenant_id, quotation_id, product_id)`

**Required Absence:**
- **No unique constraint** on tenant+quotation+product combination
- **Rationale:** Same as above (tenant isolation doesn't change reuse semantics)

#### Absence 3: No Application-Level Uniqueness Validation

**Required Absence:**
- No service-layer validation that rejects `product_id` reuse
- No validator that checks "SKU already in quotation" and blocks it

### Schema Verification Location

**Migration File:**
- `backend/alembic/versions/20260104_110400_create_schema_canon_v1_0_l1_l2_quo_pricing.py`

**Verification Method:**
- Search for: `UniqueConstraint` involving `product_id` and `quote_bom_items`
- Search for: `unique=True` on indexes involving `product_id` on `quote_bom_items`
- **Expected Result:** No matches

‚∏ª

## 6Ô∏è‚É£ Runtime Enforcement Semantics (Authoritative)

### 6.1 Allowed States

#### State A ‚Äî Same SKU Across Multiple Quotations

- `quotation_id = Q1`, `product_id = P123`
- `quotation_id = Q2`, `product_id = P123`
- `quotation_id = Q3`, `product_id = P123`

**Allowed:** ‚úÖ Yes, explicitly allowed and expected

**Use Case:** Standard components used across many projects (e.g., standard contactors, breakers)

#### State B ‚Äî Same SKU Multiple Times in Same Quotation

- `quotation_id = Q1`, `product_id = P123`, `bom_id = BOM1`, `sequence_order = 1`
- `quotation_id = Q1`, `product_id = P123`, `bom_id = BOM2`, `sequence_order = 5`
- `quotation_id = Q1`, `product_id = P123`, `bom_id = BOM3`, `sequence_order = 10`

**Allowed:** ‚úÖ Yes, explicitly allowed and expected

**Use Cases:**
- Separate feeders (different BOMs/panels)
- Separate cost heads (different categorization)
- Separate contexts (different quantities, different rates if overridden)

#### State C ‚Äî Many-to-One L1‚ÜíL2 Mapping

- Multiple L1 intent lines map to same L2 SKU
- `l1_l2_mappings` table allows multiple `l1_intent_line_id` ‚Üí same `catalog_sku_id`

**Allowed:** ‚úÖ Yes, explicitly allowed and expected

**Use Case:** Different engineering interpretations (AC1 vs AC3, different voltage) map to same commercial SKU

### 6.2 Blocked States (What Must Never Happen)

#### Blocked State 1 ‚Äî Uniqueness Constraint Added

- Schema migration adds: `UniqueConstraint('quotation_id', 'product_id')`
- **Outcome:** ‚ùå **Schema defect** (violates G-08)

**Prevention:** Freeze-gate review must reject any migration adding uniqueness on `quote_bom_items.product_id`

#### Blocked State 2 ‚Äî Validation Logic Rejects Reuse

- Service validator checks: "Does `product_id = X` already exist in `quotation_id = Y`?"
- If yes, validator rejects with error: "SKU already used in this quotation"
- **Outcome:** ‚ùå **Service defect** (violates G-08)

**Prevention:** Code review must reject any validator that enforces SKU uniqueness

#### Blocked State 3 ‚Äî Aggregation Deduplicates by SKU

- Compute logic: "For each unique `product_id` in quotation, sum quantities and rates"
- Lines with same SKU are collapsed into one line
- **Outcome:** ‚ùå **Compute bug** (wrong totals)

**Prevention:** Code review must ensure aggregation is per-line, not per-SKU

#### Blocked State 4 ‚Äî Pricing Resolver Caches Per-SKU

- Resolver caches rate by `(quotation_id, product_id)` key
- First line with SKU resolves rate; subsequent lines reuse cached rate
- **Outcome:** ‚ö†Ô∏è **May be acceptable** if idempotent and doesn't collapse lines

**Clarification:** Caching is allowed IF it remains idempotent (same inputs ‚Üí same outputs) and doesn't prevent line-level rate overrides. But caching that changes behavior is blocked.

#### Blocked State 5 ‚Äî UI Assumes 1 SKU = 1 Line

- UI shows "SKU already in quotation" warning when user tries to add same SKU again
- UI prevents adding duplicate SKU
- **Outcome:** ‚ö†Ô∏è **UI usability issue** (not authoritative, but breaks workflow)

**Clarification:** UI is not authoritative (enforcement is service/schema), but UI blocking reuse creates confusion and workflow friction.

### 6.3 When Enforcement Happens

| Event | Enforcement Layer | Behavior |
|-------|------------------|----------|
| **Create** | Schema + Service | Must allow `product_id` reuse (no uniqueness check) |
| **Update (product_id change)** | Schema + Service | Must allow setting `product_id` to value already used in quotation |
| **Validation** | Service | Validators must NOT check for SKU uniqueness |
| **Pricing Resolution** | Compute | Resolve per-line (independent of other lines with same SKU) |
| **Aggregation** | Compute | Sum all lines (do NOT deduplicate by SKU) |
| **Audit** | Audit | Write per-line (do NOT collapse by SKU) |

‚∏ª

## 7Ô∏è‚É£ Compute / Engine Semantics

### Pricing Resolution (Per-Line, Independent)

**Required Behavior:**
- Each `quote_bom_item` is resolved independently
- `resolve_line_rate()` called once per line
- Same `product_id` may appear multiple times, each resolved separately

**Example:**
```
Line 1: product_id = 123, qty = 10, rate = 100 ‚Üí amount = 1000
Line 2: product_id = 123, qty = 5, rate = 100 ‚Üí amount = 500
Line 3: product_id = 123, qty = 2, rate = 150 (override) ‚Üí amount = 300

Total for product_id 123: 1000 + 500 + 300 = 1800 (NOT collapsed)
```

**Evidence:**
- `backend/app/estimation/pricing_resolver.py` ‚Äî `resolve_line_rate()` resolves per-line
- `backend/app/estimation/pricing_resolver.py` ‚Äî `snapshot_line_rate()` persists per-line

### Aggregation (Sum All Lines, No Deduplication)

**Required Behavior:**
- Totals = SUM(line_amount) for all lines
- **Do NOT:** Group by `product_id` and sum
- **Do NOT:** Collapse lines with same SKU

**Formula:**
```
quotation_total = SUM(quote_bom_items.amount) for all items
```

**NOT:**
```
quotation_total = SUM(DISTINCT product_id amounts)  ‚ùå WRONG
```

**Evidence:**
- `backend/app/api/v1/endpoints/quotation.py` ‚Äî `_compute_quote_pricing()` sums line amounts
- `backend/app/estimation/discount_engine.py` ‚Äî line amount computation uses qty and net_rate per line

### Rate Lookup (Idempotent but Independent)

**Allowed Behavior:**
- Resolver may cache rates by `(quotation_id, product_id)` for performance
- **Required:** Caching must be idempotent (same inputs ‚Üí same outputs)
- **Required:** Caching must NOT prevent line-level rate overrides
- **Required:** Caching must NOT collapse lines

**Example (Valid Caching):**
```
Line 1: product_id = 123 ‚Üí resolve_rate() ‚Üí cache[123] = 100, use 100
Line 2: product_id = 123 ‚Üí resolve_rate() ‚Üí cache[123] = 100 (reused), use 100
Line 3: product_id = 123, override_rate = 150 ‚Üí use 150 (override takes precedence)

All three lines remain separate in aggregation.
```

**Example (Invalid Caching):**
```
Line 1: product_id = 123 ‚Üí resolve_rate() ‚Üí cache[123] = 100
Line 2: product_id = 123 ‚Üí skip resolution (use cached), BUT collapse into Line 1  ‚ùå WRONG
```

### Audit (Per-Line Traceability)

**Required Behavior:**
- Audit events written at line level (`resource_id = line_item_id`)
- Each line with same SKU has separate audit trail
- Reuse does NOT prevent traceability

**Evidence:**
- `backend/app/audit/logger.py` ‚Äî Audit patterns use line-level `resource_id`

‚∏ª

## 8Ô∏è‚É£ Audit & Traceability Expectations

### Audit Requirements (Standard ‚Äî No Special Handling)

**Standard Audit Events:**
- Line creation, update, deletion (standard audit)
- Rate changes, override application (G-04 audit)
- Apply-recalc operations (Policy-1 audit)

**Required Behavior:**
- Each line audited independently
- `resource_id = <line_item_id>` (not `product_id`)
- Same SKU appearing multiple times = multiple audit records

### Traceability Guarantee

**Each line item is independently traceable:**
- Who created it
- Who modified it
- When rate was resolved
- When override was applied
- When it was deleted (if applicable)

**Reuse does NOT break traceability:**
- Multiple lines with same SKU each have their own audit trail
- Can trace why each line exists (different context, different quantity, etc.)

‚∏ª

## 9Ô∏è‚É£ Explicit Non-Goals (VERY IMPORTANT)

### Does NOT Prevent Deduplication in UI Display

**Non-Goal:** G-08 does NOT prevent UI from grouping lines by SKU for display purposes.

**Clarification:** UI may show "SKU X appears 3 times" with expandable list. UI grouping is fine. What's blocked is system-level deduplication that affects totals or prevents reuse.

### Does NOT Require Unique Identifiers for Lines

**Non-Goal:** G-08 does NOT require each line to have a unique identifier beyond `id`.

**Clarification:** Each line already has unique `id`. G-08 doesn't add requirements; it prevents false constraints.

### Does NOT Block Future Uniqueness for Other Columns

**Non-Goal:** G-08 does NOT prevent uniqueness constraints on other columns.

**Clarification:** Other columns may have uniqueness (e.g., `(quotation_id, sequence_order)`). G-08 only protects `product_id` reuse.

### Does NOT Require Catalog-Level Changes

**Non-Goal:** G-08 does NOT require changes to `products` or `catalog_skus` tables.

**Clarification:** Catalog tables may have their own uniqueness rules (e.g., `(tenant_id, sku)` unique). G-08 is about quotation workspace reuse, not catalog uniqueness.

### Does NOT Prevent Future Deduplication Features

**Non-Goal:** G-08 does NOT prevent future "merge duplicate lines" features.

**Clarification:** If users want to manually merge lines with same SKU, that's a workflow feature (opt-in). G-08 prevents automatic/systematic deduplication that breaks reuse.

### Does NOT Enforce Catalog Integrity

**Non-Goal:** G-08 does NOT enforce that `product_id` references valid products.

**Clarification:** FK constraint enforces referential integrity. G-08 is about reuse semantics, not referential integrity.

‚∏ª

## üîü Failure & Recovery Semantics

### Failure Mode 1 ‚Äî Uniqueness Constraint Added (Schema Migration)

**Trigger:** Migration adds `UniqueConstraint('quotation_id', 'product_id')` to `quote_bom_items`

**Error Returned:**
- **DB Error:** `IntegrityError: duplicate key value violates unique constraint`
- **User Impact:** System rejects valid workflow (same SKU in multiple contexts)

**Recovery:**
- **Immediate:** Revert migration, remove uniqueness constraint
- **Investigation:** Review migration approval process (should have caught this)
- **Prevention:** Freeze-gate checklist must verify absence of uniqueness on `product_id`

**Who Can Recover:** DBA/developer (migration revert)

### Failure Mode 2 ‚Äî Validation Logic Rejects Reuse

**Trigger:** Service validator checks for SKU uniqueness and rejects second use

**Error Returned:**
- **HTTP Status:** 400 Bad Request
- **Error Code:** `SKU_ALREADY_IN_QUOTATION` (hypothetical)
- **Message:** "Product ID 123 already exists in this quotation"

**Recovery:**
- **Immediate:** Remove uniqueness validation logic
- **Investigation:** Code review should have caught this
- **Prevention:** Code review checklist must verify validators allow reuse

**Who Can Recover:** Developer (code fix)

### Failure Mode 3 ‚Äî Aggregation Deduplicates by SKU

**Trigger:** Compute logic groups by `product_id` and sums quantities, collapsing lines

**Error Returned:**
- **No explicit error** ‚Äî system silently produces wrong totals
- **User Impact:** Quotation totals are incorrect (understated if quantities not summed correctly)

**Recovery:**
- **Immediate:** Fix aggregation logic (sum all lines, no grouping)
- **Investigation:** Review compute logic, add tests for SKU reuse scenarios
- **Prevention:** Unit tests must cover SKU reuse cases

**Who Can Recover:** Developer (code fix) + QA (test coverage)

### Failure Mode 4 ‚Äî UI Blocks Reuse (Non-Critical)

**Trigger:** UI shows warning or prevents adding same SKU to quotation

**Error Returned:**
- **UI Warning:** "This SKU is already in the quotation" (may block user action)

**Recovery:**
- **Immediate:** Remove UI uniqueness check (or change to informational message)
- **Investigation:** UI/UX review
- **Prevention:** UI requirements must allow SKU reuse

**Who Can Recover:** UI developer (code fix) ‚Äî not critical (service layer still allows reuse)

‚∏ª

## 1Ô∏è‚É£1Ô∏è‚É£ Future Extension Rules (Controlled)

### Possible Extensions

#### Extension 1: SKU Reuse Limit (Per Quotation)

**What Could Be Extended:**
- Add optional limit: "Maximum N instances of same SKU per quotation"
- Exceeds limit ‚Üí warning (not error)

**What MUST Happen Before Extension:**
1. **Decision:** Governance approval (workflow requirement, not data integrity)
2. **Schema:** Add optional `sku_reuse_limit INTEGER NULL` to `quotations` table
3. **Doc Update:** This micro-spec updated (add limit semantics to Section 6.2)
4. **Service:** Update validation logic to check limit (warning only, not error)
5. **Tests:** Comprehensive tests

**Change Control:** Must follow Freeze-Gate process

**Note:** This would be a workflow convenience feature, not a data integrity requirement. G-08 core (uniqueness absence) remains unchanged.

#### Extension 2: SKU Reuse Reporting

**What Could Be Extended:**
- Add reporting: "Show all quotations using SKU X"
- Add analytics: "Most reused SKUs across quotations"

**What MUST Happen Before Extension:**
1. **Decision:** Business requirement (reporting feature)
2. **Schema:** No schema changes needed (query optimization may need indexes)
3. **Doc Update:** This micro-spec updated (add reporting semantics)
4. **Service:** Add reporting endpoints
5. **Tests:** Comprehensive tests

**Change Control:** Must follow Freeze-Gate process

**Note:** Reporting is read-only and doesn't affect reuse semantics.

#### Extension 3: Automatic Line Merging (User-Initiated)

**What Could Be Extended:**
- Add feature: "Merge duplicate lines" (user-initiated, opt-in)
- Combines lines with same SKU, sums quantities

**What MUST Happen Before Extension:**
1. **Decision:** Workflow requirement (user convenience)
2. **Schema:** No schema changes needed
3. **Doc Update:** This micro-spec updated (clarify: opt-in merge is allowed, automatic merge is blocked)
4. **Service:** Add merge logic (must be explicit user action)
5. **Audit:** Merge must be audited
6. **Tests:** Comprehensive tests

**Change Control:** Must follow Freeze-Gate process

**Note:** Opt-in merge is workflow feature. Automatic/systematic merge remains blocked by G-08.

### Extension Guardrails

**All extensions must:**
- Maintain core G-08 invariant: no uniqueness constraint on `product_id` reuse
- Maintain per-line aggregation (totals = sum of all lines)
- Maintain per-line audit (traceability)
- Not block legitimate reuse scenarios

‚∏ª

## 1Ô∏è‚É£2Ô∏è‚É£ Freeze-Gate Declaration

- **Status:** üîí LOCKED
- **Effective Date:** 2026-01-27
- **Change Requires:** Phase-5 Senate approval

**Locked Guarantees:**
- No uniqueness constraint on `quote_bom_items.product_id` reuse
- Aggregation sums all lines (no deduplication by SKU)
- Pricing resolution is per-line (independent of other lines)
- Audit remains per-line (traceability preserved)
- Future migrations must not add uniqueness constraints on `product_id` reuse

‚∏ª

---

**Micro-Spec Version:** 1.0  
**Based on Template:** Tier-1 Micro-Spec Template v1.0  
**Related Documents:**
- A1.9 (Original G-08 documentation)
- VALIDATION_GUARDRAILS_G1_G7.md (Consolidated guardrails)
- G-04 (RateSource consistency) ‚Äî related (each reused line must have traceable rate)
- G-07 (Policy-1 Preview vs Apply) ‚Äî related (reused lines must be deterministic in preview/apply)

**Implementation Evidence:**
- `backend/alembic/versions/20260104_110400_create_schema_canon_v1_0_l1_l2_quo_pricing.py` (absence of uniqueness constraints, lines 475-485)
- `backend/app/api/v1/endpoints/quotation.py` (_compute_quote_pricing ‚Äî aggregation logic)
- `backend/app/estimation/discount_engine.py` (line amount computation)
- `backend/app/estimation/pricing_resolver.py` (per-line resolution)
- `backend/app/audit/logger.py` (per-line audit)

**Schema Verification:**
- **No UniqueConstraint** on `quote_bom_items` involving `product_id`
- **Non-unique indexes only:** `idx_quote_bom_items_product_id` (performance, not uniqueness)
- **FK constraint:** `product_id` FK to `products.id` (referential integrity, not uniqueness)

