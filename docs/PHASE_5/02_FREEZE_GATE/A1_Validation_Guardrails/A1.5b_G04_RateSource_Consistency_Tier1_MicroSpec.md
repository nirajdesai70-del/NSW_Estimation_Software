# G-04 ‚Äî RateSource Consistency (Tier-1 Micro-Spec)

> **‚ö†Ô∏è IMPORTANT: This is an ADDITIVE enhancement to A1.5, not a replacement.**  
> The primary reference remains `A1.5_Guardrail_G04_RateSource_Consistency.md`.  
> This micro-spec provides governance-grade depth for audit, future-proofing, and developer clarity.  
> Both documents work together: A1.5 for freeze-gate verification, A1.5b for deep implementation guidance.

**Phase:** Phase-5  
**Category:** A ‚Äî Validation Guardrails (Tier-1)  
**Rule ID:** G-04  
**Status:** üîí LOCKED  
**Date:** 2026-01-27  
**Template:** Tier-1 Micro-Spec (CANONICAL)  
**Primary Reference:** A1.5_Guardrail_G04_RateSource_Consistency.md (Freeze-Gate Verified)

‚∏ª

## 1Ô∏è‚É£ Rule Identifier

- **Rule ID:** G-04
- **Category:** Validation / Runtime Control
- **Phase Introduced:** Phase-5
- **Risk Class:** üî¥ Tier-1 (Financial / Audit / Legal)

‚∏ª

## 2Ô∏è‚É£ Intent (What This Rule Protects)

**Protection:** Every quotation line must have a deterministic, auditable rate origin so totals are traceable and reproducible. The system must never allow "ambiguous" or "mixed" rate origins that would make it impossible to explain why a particular rate was used, how it was calculated, or who authorized any manual overrides.

**If Violated:**
- Pricing changes become untraceable, making audits impossible
- Disputes cannot be resolved (cannot prove rate origin)
- Preview vs Apply outcomes may diverge silently
- Manual overrides may be lost during price refresh cycles
- Financial calculations become non-reproducible

**Why Beyond Schema:** Schema can enforce that a field exists, but cannot enforce that the persisted value matches the calculation logic used, or that manual overrides are properly authorized and documented.

‚∏ª

## 3Ô∏è‚É£ Business Rationale (Why This Must Exist)

### Financial Risk Prevented
- **Silent pricing changes:** Without clear rate_source tracking, system refreshes or recalculations could change rates without authorization, causing incorrect quotations to be sent to customers
- **Reproducibility loss:** Inability to explain why a quotation total differs from expectations leads to revenue disputes

### Audit Risk Prevented
- **Compliance failure:** Financial audits require traceability of every pricing decision; missing or inconsistent rate_source makes audits impossible
- **Legal defensibility:** In contract disputes, inability to prove rate origin creates legal liability

### User Behavior Risk Prevented
- **Unauthorized overrides:** Without proper rate_source tracking, manual overrides may occur without proper authorization (role + reason)
- **Price refresh confusion:** Users may not understand why their manual overrides are preserved vs overwritten

### Why Common Sense Is Not Sufficient
- Multiple code paths can set rates (pricelist resolution, manual override, recalc, apply-recalc)
- Rate_source may be set at different times than the rate itself
- Preview vs Apply semantics require deterministic rate_source matching
- Manual overrides must survive price refreshes, but system rates should update

‚∏ª

## 4Ô∏è‚É£ Canonical Scope (Where It Applies)

| Dimension | Applies | Notes |
|-----------|---------|-------|
| Schema | ‚úÖ | Enum constraint on `rate_source`; columns exist for override tracking |
| Service Layer | ‚úÖ | **Primary enforcement** ‚Äî validator checks role + reason for MANUAL |
| Compute Engine | ‚úÖ | **Primary enforcement** ‚Äî resolver ensures rate_source matches applied rate |
| API / Validator | ‚úÖ | Early rejection of invalid override requests (role, reason, rate validation) |
| Audit | ‚úÖ | Required ‚Äî override operations and recalculation actions are logged |
| UI | ‚ùå | UI never authoritative; service layer enforces |

‚∏ª

## 5Ô∏è‚É£ Schema Behavior (Hard Guarantees)

### Tables & Columns

**Table:** `quote_bom_items`

**Primary Columns:**
- `rate_source` (VARCHAR(50))
  - **DB Enum Values (CHECK constraint enforced):** `'PRICELIST'`, `'MANUAL_WITH_DISCOUNT'`, `'FIXED_NO_DISCOUNT'`, `'UNRESOLVED'`
  - **Default:** `server_default='UNRESOLVED'` (migration: `20260104_110400`)
  - **NOT NULL**
  - **Constraint Name:** `chk_quote_bom_items_rate_source` (plural "items")

**Internal Enum Mapping (Service Layer):**
- Internal enum: `RateSource.MANUAL` ‚Üí DB value: `'MANUAL_WITH_DISCOUNT'`
- Internal enum: `RateSource.PRICELIST` ‚Üí DB value: `'PRICELIST'`
- **Mapping layer:** `backend/app/estimation/rate_source_map.py` (mandatory for all DB writes)

- `rate` (DECIMAL)
  - Precision: As defined in schema (typically 10,2 or 15,4)
  - **NOT NULL**
  - Must match the source indicated by `rate_source`

**Override Tracking Columns (for MANUAL):**
- `override_rate` (DECIMAL)
  - Precision: Matches `rate`
  - NULLABLE (NULL when `rate_source != MANUAL`)

- `override_reason` (TEXT)
  - NULLABLE (NULL when `rate_source != MANUAL`)
  - Must be present when `rate_source = MANUAL`

- `overridden_by` (INTEGER, FK to `users`)
  - NULLABLE (NULL when `rate_source != MANUAL`)

- `overridden_at` (TIMESTAMP)
  - NULLABLE (NULL when `rate_source != MANUAL`)

### Constraints

**Explicit Constraints:**
- `rate_source` enum check (prevents invalid values)
- Precision constraints on decimal fields (prevents storage errors)

**Explicit Absences (Critical):**
- **NO CHECK constraint** that enforces `rate_source = MANUAL ‚Üí override_rate IS NOT NULL`
  - **Rationale:** Enforcement is service-layer only (allows future flexibility, avoids migration complexity)
  - **Enforcement:** Service validator must enforce this invariant

- **NO CHECK constraint** that enforces `rate_source = PRICELIST ‚Üí override_rate IS NULL`
  - **Rationale:** Same as above

### Defaults

- `rate_source`: **Default `'UNRESOLVED'`** (verified in migration `20260104_110400`, line 436)
- `rate`: **Default `0`** (verified in migration)
- `override_rate`, `override_reason`, `overridden_by`, `overridden_at`: Default to NULL

### Evidence Location

**Migration Files:**
- `backend/alembic/versions/20260104_120000_add_phase5_override_columns.py`
- `backend/alembic/versions/20260104_130100_fix_override_rate_precision.py`

‚∏ª

## 6Ô∏è‚É£ Runtime Enforcement Semantics (Authoritative)

### 6.1 Allowed States

#### State A: PRICELIST Rate
- `rate_source = 'PRICELIST'`
- `rate = <effective SKU rate for quote context>`
- `override_rate = NULL`
- `override_reason = NULL`
- `overridden_by = NULL`
- `overridden_at = NULL`

**Creation:** Set by pricing resolver when SKU price is found and applied.

**Transitions:** Can transition to `MANUAL` via authorized override. Can transition to `UNRESOLVED` if price becomes unavailable.

#### State B: MANUAL Override
- `rate_source = 'MANUAL_WITH_DISCOUNT'` (DB value, mapped from internal `RateSource.MANUAL`)
- `rate = override_rate` (must match)
- `override_rate IS NOT NULL` (and `> 0`)
- `override_reason IS NOT NULL` (non-empty string)
- `overridden_by IS NOT NULL` (valid user_id with Reviewer/Approver role)
- `overridden_at IS NOT NULL` (timestamp of override)

**Mapping Note:** Internal code uses `RateSource.MANUAL`, which is mapped to DB `'MANUAL_WITH_DISCOUNT'` via `rate_source_map.py::internal_to_db_rate_source()`. This mapping is mandatory for all DB persistence operations.

**Creation:** Set only via authorized override request (validator enforces role + reason).

**Transitions:** Can transition back to `PRICELIST` if user clears override and refreshes price. **Must NOT** transition automatically during price refresh cycles (manual overrides persist).

#### State C: FIXED_NO_DISCOUNT
- `rate_source = 'FIXED_NO_DISCOUNT'`
- `rate = <fixed rate>`
- Override columns: May be NULL or populated depending on how fixed rate was set

**Note:** Governed by G-06; separate micro-spec covers this.

#### State D: UNRESOLVED
- `rate_source = 'UNRESOLVED'`
- `rate = 0` (normalized per G-05)
- Override columns: NULL

**Note:** Governed by G-05; separate micro-spec covers this.

### 6.2 Blocked States

#### Blocked State 1: Ambiguous Rate Source
- `rate_source = NULL` ‚Üí **BLOCKED**
- `rate_source = <invalid enum value>` ‚Üí **BLOCKED** (schema constraint)

#### Blocked State 2: MANUAL Without Authorization
- `rate_source = 'MANUAL_WITH_DISCOUNT'` AND `override_rate IS NULL` ‚Üí **BLOCKED** (service validator)
- `rate_source = 'MANUAL_WITH_DISCOUNT'` AND `override_reason IS NULL OR empty` ‚Üí **BLOCKED** (service validator)
- `rate_source = 'MANUAL_WITH_DISCOUNT'` AND `overridden_by` is not Reviewer/Approver ‚Üí **BLOCKED** (service validator)

**Note:** Service layer checks internal `RateSource.MANUAL` enum; DB stores `'MANUAL_WITH_DISCOUNT'`.

#### Blocked State 3: Rate Mismatch
- `rate_source = 'MANUAL_WITH_DISCOUNT'` AND `rate != override_rate` ‚Üí **BLOCKED** (service validator / resolver)
- **Rationale:** Applied rate must match the source it claims to come from

#### Blocked State 4: PRICELIST With Override Fields Populated
- `rate_source = 'PRICELIST'` AND `override_rate IS NOT NULL` ‚Üí **BLOCKED** (service validator)
- **Rationale:** Prevents confusion about rate origin

#### Blocked State 5: Invalid Enum Value
- `rate_source` NOT IN `('PRICELIST', 'MANUAL_WITH_DISCOUNT', 'FIXED_NO_DISCOUNT', 'UNRESOLVED')` ‚Üí **BLOCKED** (schema CHECK constraint)
- **Constraint:** `chk_quote_bom_items_rate_source` enforces exact enum set

### 6.3 When Enforcement Happens

#### On Create
- **Service layer:** Validator checks role + reason if MANUAL
- **Resolver:** Sets `rate_source` based on resolution outcome
- **Persistence:** Both `rate` and `rate_source` written atomically

#### On Update (Rate Change)
- **Service layer:** If changing to MANUAL, validator enforces role + reason
- **Resolver:** If recalculating from PRICELIST, updates both `rate` and `rate_source`
- **Invariant:** `rate_source` must remain consistent with how `rate` was determined

#### On Update (Other Fields)
- **Service layer:** No direct enforcement (rate_source not affected)
- **Exception:** If `rate_source = MANUAL`, changing `rate` directly should also update `override_rate` (or be blocked)

#### On Delete
- **No enforcement** (deletion policy handled by A5 is_locked, not G-04)

#### On Preview
- **Compute engine:** Uses same resolution logic as apply
- **Invariant:** Preview must produce same `rate_source` determination as apply would
- **No persistence:** Preview does not write to DB (Policy-1)

#### On Apply-Recalc
- **Resolver:** Re-resolves rates for PRICELIST items (respects manual overrides)
- **Invariant:** Manual overrides are preserved; PRICELIST rates are refreshed
- **Persistence:** Writes both `rate` and `rate_source` as snapshots

‚∏ª

## 7Ô∏è‚É£ Compute / Engine Semantics

### Rate Resolution Logic

**Deterministic Resolution Order:**
1. If manual override exists (`override_rate IS NOT NULL` AND not cleared):
   - `rate = override_rate`
   - Internal: `rate_source = RateSource.MANUAL`
   - DB: `rate_source = 'MANUAL_WITH_DISCOUNT'` (via mapping layer)
   - **Stop resolution**

2. If SKU price found in pricelist:
   - `rate = <effective SKU rate for quote context>`
   - Internal: `rate_source = RateSource.PRICELIST`
   - DB: `rate_source = 'PRICELIST'`
   - **Stop resolution**

3. If SKU missing or price unavailable:
   - `rate = 0`
   - DB: `rate_source = 'UNRESOLVED'`
   - **Stop resolution**

**Important:** Resolution must be **idempotent** ‚Äî same inputs ‚Üí same outputs.

### Rate Source Mapping (Internal ‚Üî DB)

**Internal Representation:**
- Service layer uses `RateSource` enum (`RateSource.PRICELIST`, `RateSource.MANUAL`)
- Defined in: `backend/app/estimation/types.py`

**DB Storage:**
- **Mandatory mapping layer:** `backend/app/estimation/rate_source_map.py`
- Internal `RateSource.MANUAL` ‚Üí DB `'MANUAL_WITH_DISCOUNT'` (locked, Option A)
- Internal `RateSource.PRICELIST` ‚Üí DB `'PRICELIST'`
- All DB persistence operations MUST use `internal_to_db_rate_source()` function

**Invariant:** Internal representation MUST map deterministically to DB representation via mapping layer. Direct DB writes without mapping are forbidden.

### Quantization & Precision

**Decimal Normalization:**
- All rates are quantized using `qrate()` function (`backend/app/estimation/decimal_norm.py`)
- Precision matches schema DECIMAL precision
- **Rationale:** Prevents floating-point drift, ensures deterministic calculations

### Totals Calculation

**Line Amount:**
- `line_amount = rate √ó quantity √ó (1 - discount_pct/100)`
- `rate_source` does NOT affect calculation formula
- `rate_source` only affects which rate value is used

**Roll-up Totals:**
- Sum of line amounts (independent of rate_source)
- Each line's `rate_source` must be traceable for audit

### Derived Fields

**No derived fields** depend on `rate_source` directly. However:
- `net_rate` depends on `rate` (which depends on resolution, which determines `rate_source`)
- `amount_total` depends on `rate` (same chain)

‚∏ª

## 8Ô∏è‚É£ Audit & Traceability Expectations

### Required Audit Events

#### Event 1: Manual Override Creation
- **Event Type:** `OVERRIDE_RATE` (or equivalent)
- **Required Fields:**
  - `resource_type = 'quote_bom_item'`
  - `resource_id = <line_item_id>`
  - `action = 'override_rate'`
  - `user_id = <overridden_by>`
  - `timestamp = <overridden_at>`
  - `metadata = {`
    - `old_rate: <previous_rate>`
    - `new_rate: <override_rate>`
    - `rate_source: 'MANUAL'`
    - `override_reason: <override_reason>`
  - `}`

**Enforcement:** Mandatory (audit failure = defect)

#### Event 2: Apply-Recalc (Rate Source Changes)
- **Event Type:** `APPLY_RECALC` (or equivalent)
- **Required Fields:**
  - `resource_type = 'quote_bom_item'` (or batch-level)
  - `resource_id = <line_item_id>` (or quotation_id for batch)
  - `action = 'apply_recalc'`
  - `user_id = <user_who_triggered>`
  - `timestamp = <recalc_timestamp>`
  - `metadata = {`
    - `rate_source: <new_rate_source>`
    - `rate: <new_rate>`
    - `previous_rate_source: <old_rate_source>` (if changed)
    - `previous_rate: <old_rate>` (if changed)
  - `}`

**Enforcement:** Mandatory (audit failure = defect)

### Recommended Audit Events

#### Event 3: Rate Refresh (PRICELIST Update)
- **Event Type:** `REFRESH_PRICE` (or equivalent)
- **Recommended Fields:**
  - Similar to Apply-Recalc but focused on PRICELIST updates
  - Useful for tracking when prices change from external sources

**Enforcement:** Recommended (not mandatory in MVP, but highly recommended for Phase-6)

### Audit Evidence Location

**Implementation:**
- `backend/app/audit/logger.py` (AuditLogger.log_event())

**Tests:**
- `backend/tests/phase5/test_apply_recalc.py` (apply audit)
- `backend/tests/phase5/test_pricing_resolver.py` (override audit)

‚∏ª

## 9Ô∏è‚É£ Explicit Non-Goals (VERY IMPORTANT)

### Does NOT Block Edits

**Non-Goal:** G-04 does NOT prevent users from editing rates or changing `rate_source`.

**Clarification:** G-04 ensures that when a rate is set, its source is properly tracked and authorized. It does NOT enforce read-only behavior. (That is handled by A5 is_locked or future workflow controls.)

### Does NOT Cascade to Parent

**Non-Goal:** G-04 does NOT enforce that parent BOM/Panel/Quotation have consistent rate_source.

**Clarification:** Each line item has its own `rate_source`. Parent totals are sums of line amounts, regardless of line-level rate_source variety.

### Does NOT Auto-Correct User Input

**Non-Goal:** G-04 does NOT automatically change invalid rate_source values.

**Clarification:** Invalid states are **rejected** (hard fail), not auto-corrected. User must fix the input explicitly.

### Does NOT Enforce Price Refresh Policy

**Non-Goal:** G-04 does NOT define when prices should be refreshed or how often.

**Clarification:** G-04 ensures that when refresh happens, manual overrides are preserved and rate_source is updated correctly. The **when** is governed by Policy-1 (Preview vs Apply) and future refresh policies.

### Does NOT Prevent Future Rate Sources

**Non-Goal:** G-04 does NOT lock the enum to only PRICELIST/MANUAL/UNRESOLVED/FIXED.

**Clarification:** Future rate sources (e.g., CONTRACT, ESTIMATE) can be added via schema migration + resolver update + doc update. G-04's requirement is that **whatever** rate_source exists, it must be consistent with how the rate was determined.

‚∏ª

## üîü Failure & Recovery Semantics

### Failure Mode 1: Unauthorized Manual Override Attempt

**Trigger:** User with role < Reviewer/Approver attempts to set `rate_source = MANUAL`.

**Error Returned:**
- **HTTP Status:** 403 Forbidden (or 400 Bad Request depending on endpoint)
- **Error Code:** `OVERRIDE_NOT_AUTHORIZED` (or equivalent)
- **Message:** "Manual rate override requires Reviewer or Approver role"

**Recovery:**
- **Manual:** User must obtain proper role or request override from authorized user
- **Automatic:** None (security control, no auto-recovery)

**Who Can Recover:** Authorized user (Reviewer/Approver) must perform the override

### Failure Mode 2: Missing Override Reason

**Trigger:** User attempts to set `rate_source = MANUAL` without providing `override_reason`.

**Error Returned:**
- **HTTP Status:** 400 Bad Request
- **Error Code:** `OVERRIDE_REASON_REQUIRED`
- **Message:** "Manual rate override requires a reason"

**Recovery:**
- **Manual:** User must provide valid reason
- **Automatic:** None

**Who Can Recover:** Same user (just needs to add reason)

### Failure Mode 3: Invalid Rate Value

**Trigger:** User attempts to set `override_rate <= 0` or `override_rate = NULL`.

**Error Returned:**
- **HTTP Status:** 400 Bad Request
- **Error Code:** `INVALID_OVERRIDE_RATE`
- **Message:** "Override rate must be greater than zero"

**Recovery:**
- **Manual:** User must provide valid rate
- **Automatic:** None

**Who Can Recover:** Same user (just needs to fix rate)

### Failure Mode 4: Rate Source Mismatch (Internal Error)

**Trigger:** Resolver sets `rate_source = 'PRICELIST'` but `rate` does not match pricelist lookup (rare internal bug).

**Error Returned:**
- **HTTP Status:** 500 Internal Server Error
- **Error Code:** `RATE_SOURCE_MISMATCH`
- **Message:** "Internal error: Rate source does not match calculated rate"

**Recovery:**
- **Manual:** Admin must investigate resolver logic
- **Automatic:** System should log error and reject the operation (fail-safe)

**Who Can Recover:** Developer/admin (code fix required)

### Failure Mode 5: PRICELIST Missing SKU / Price

**Trigger:** Pricelist resolution cannot produce a rate (SKU missing or price unavailable).

**Error Returned:**
- **NOT an error** ‚Äî transitions to `rate_source = 'UNRESOLVED'`, `rate = 0` (per G-05)
- **UI Behavior:** Should indicate unresolved state to user

**Recovery:**
- **Manual:** User must either:
  - Provide manual override (if authorized)
  - Map to different SKU
  - Wait for pricelist update
- **Automatic:** None (this is expected behavior for missing prices)

**Who Can Recover:** User (via manual override or SKU remapping)

‚∏ª

## 1Ô∏è‚É£1Ô∏è‚É£ Future Extension Rules (Controlled)

### Potential Extensions

#### Extension 1: Additional Rate Sources

**What Could Be Extended:**
- Add `CONTRACT` rate source (contract-specific pricing)
- Add `ESTIMATE` rate source (engineer-estimated pricing)
- Add `HISTORICAL` rate source (based on previous quotation)

**What MUST Happen Before Extension:**
1. **Decision:** Phase-5 Senate (or Phase-6 governance) approves new rate source
2. **Migration:** Schema migration adds enum value
3. **Doc Update:** 
   - This micro-spec updated (add new state to Section 6.1)
   - Data Dictionary updated
   - Resolver documentation updated
4. **Audit Update:** Audit events updated to capture new rate source
5. **Resolver Update:** `pricing_resolver.py` updated with resolution logic for new source
6. **Tests:** Comprehensive tests for new rate source

**Change Control:** Must follow Phase-5 Freeze-Gate process (or Phase-6 equivalent)

#### Extension 2: Partial Override (Discount-Only Override)

**What Could Be Extended:**
- Allow override of discount while keeping pricelist rate
- New state: `rate_source = 'PRICELIST_WITH_OVERRIDE_DISCOUNT'`

**What MUST Happen Before Extension:**
1. **Decision:** Governance approval
2. **Schema:** Add enum value + override_discount columns
3. **Doc Update:** This micro-spec + G-06 (discount rules) updated
4. **Resolver:** Update resolution logic
5. **Tests:** Comprehensive tests

**Change Control:** Must follow Freeze-Gate process

#### Extension 3: Time-Bounded Overrides

**What Could Be Extended:**
- Overrides expire after X days
- System reverts to PRICELIST after expiration

**What MUST Happen Before Extension:**
1. **Decision:** Governance approval (affects audit trail)
2. **Schema:** Add `override_expires_at` column
3. **Doc Update:** This micro-spec updated (Section 6.1 State B)
4. **Resolver:** Update resolution logic to check expiration
5. **Audit:** Update audit to capture expiration events
6. **Tests:** Comprehensive tests

**Change Control:** Must follow Freeze-Gate process

### Extension Guardrails

**All extensions must:**
- Maintain traceability (audit requirements)
- Maintain determinism (idempotent resolution)
- Not break existing quotations (backward compatibility)
- Update this micro-spec (documentation is non-negotiable)

‚∏ª

## 1Ô∏è‚É£2Ô∏è‚É£ Freeze-Gate Declaration

- **Status:** üîí LOCKED
- **Effective Date:** 2026-01-27
- **Change Requires:** Phase-5 Senate approval

**Locked Semantics:**
- Schema constraints: FROZEN (no changes without approval)
- Resolution logic: FROZEN (idempotent behavior must be preserved)
- Override authorization: FROZEN (role + reason requirements)
- Audit requirements: FROZEN (traceability is non-negotiable)

**Exceptions:**
- Bug fixes (with Senate notification)
- Extensions (with full Freeze-Gate process)

‚∏ª

---

**Micro-Spec Version:** 1.0  
**Based on Template:** Tier-1 Micro-Spec Template v1.0  
**Related Documents:**
- A1.5 (Original G-04 documentation)
- VALIDATION_GUARDRAILS_G1_G7.md (Consolidated guardrails)
- A5 (is_locked) ‚Äî related but separate concern
- A6 (CostHead) ‚Äî related but separate concern

**Implementation Evidence:**
- `backend/app/validators/override_rules.py`
- `backend/app/estimation/pricing_resolver.py`
- `backend/app/estimation/rate_source_map.py`
- `backend/app/estimation/decimal_norm.py`
- `backend/app/audit/logger.py`
- `backend/tests/phase5/test_pricing_resolver.py`

